\begin{SCn}
\begin{small}

% https://oberoncore.ru/_media/library/c_pfister_component_software.pdf
\scnheader{Phister.C.ComponentSoftware-1997art}
\scnrelfrom{тип}{статья}
\scnrelfromlist{ключевой знак}{комопнент;компоненто-ориентированное программирование}

\scntext{аннотация}{Появление компонентного программного обеспечения может быть самым важным событием в индустрии программного обеспечения с момента появления языков программирования высокого уровня. Компонентное программное обеспечение сочетает в себе преимущества заказного и стандартного программного обеспечения. Это позволяет создавать решения, более приспособолены к эволюции, т. е. которые лучше масштабируются, которые легче обслуживать, которые можно расширять с течением времени и постепенно модернизировать.}

\scnrelfrom{цитата}{Quote1.Phister.C.ComponentSoftware-1997art.p3}
\scnaddlevel{1}
    \scneq{\scnfileitem{A component is a unit of composition with a contractually specified interface and explicit context dependencies only. Components can be deployed independently of each other and are subject to composition by third parties.}}
    %\scneq{\scnfileitem{Компонент — это элемент конструкции с определенным, зафиксированным в спецификации, интерфейсом и явными зависимостями от контекста. Компоненты могут распространяться независимо друг от друга и компоноваться третьей стороной.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote2.Phister.C.ComponentSoftware-1997art.p3}
\scnaddlevel{1}
    \scneq{\scnfileitem{It is a fundamental requirement of component software that components may be developed and sold independently of each other, and yet can be combined by the customer.}}
    %\scneq{\scnfileitem{Фундаментальное требование к компонентному ПО состоит в том, чтобы компоненты могли разрабатываться и продаваться независимо друг от друга, и, таким образом, могли комбинироваться потребителем.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote.Phister.C.ComponentSoftware-1997art.p4}
\scnaddlevel{1}
    \scneq{\scnfileitem{...component software is a composition of components, some of which may be standard components and others may be custom components.}}
    %\scneq{\scnfileitem{...компонентное программное обеспечение является конструкцией из компонентов, часть из которых могут быть серийными компонентами, а другие — изготовленными на заказ}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote.Phister.C.ComponentSoftware-1997art.p4-5}
\scnaddlevel{1}
    \scneq{\scnfileitem{By splitting a complex problem into simpler problems which can be solved independently, the problem becomes more manageable.}}
    %\scneq{\scnfileitem{При разбиении сложной проблемы на более простые, которые могут быть решены независимо друг от друга, проблема становится более управляемой.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote1.Phister.C.ComponentSoftware-1997art.p5}
\scnaddlevel{1}
    \scneq{\scnfileitem{Components can be developed in parallel if it is clearly defined in advance what each component should provide, so that a programmer can immediately use the interface of a component currently being developed by another team member - even though its implementation doesn't exist yet.}}
    %\scneq{\scnfileitem{Компоненты могут разрабатываться параллельно, если заранее ясно определено, что каждый компонент должен предоставлять, так что программист может немедленно использовать интерфейс компонента, который разрабатывается другим сотрудником — даже если его реализация еще не существует.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote2.Phister.C.ComponentSoftware-1997art.p5}
\scnaddlevel{1}
    \scneq{\scnfileitem{It may happen in a software project that someone remembers that some part of the current problem had already been solved for an earlier project. If this partial solution has the form of a separate component, it can be reused in the new project, thus saving time and cost.}}
    %\scneq{\scnfileitem{В программном проекте может случиться так, что кто-то вспомнит, что какая-либо часть текущей задачи уже была решена в предыдущем проекте. Если это частичное решение было оформлено как независимый компонент, оно может быть повторно использовано в новом проекте. При этом произойдет экономия времени и средств.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote3.Phister.C.ComponentSoftware-1997art.p5}
\scnaddlevel{1}
    \scneq{\scnfileitem{They [buyers] get customized solutions quicker. They can save time by buying components on the market, and thereby it becomes less likely that the solutions are obsolete by the time they are ready for use. Component software allows to add new functionality over time, by adding new components to an already existing solution. In this way, a solution can be extended to handle new needs over time.}}
    %\scneq{\scnfileitem{Они [покупатели] могут сэкономить время за счет покупки компонентов на рынке, и тем самым снижают вероятность того, что программные решения уже устареют к моменту своей готовности. Компонентное ПО позволяет добавлять со временем новую функциональность, присоединяя новые компоненты к уже существующим решениям. Таким образов, решение может расширяться, чтобы соответствовать новым нуждам.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote.Phister.C.ComponentSoftware-1997art.p7}
\scnaddlevel{1}
    \scneq{\scnfileitem{Component implementation is still a difficult engineering problem. The design of component interfaces is even more challenging. It takes well educated and experienced engineers to do it. Developing a truly reusable high-quality component cannot be achieved "in one shot"; it requires iterative improvement over a long time, and therefore is expensive.}}
    %\scneq{\scnfileitem{Компонентная реализация — все еще трудная инженерная проблема. Проектирование интерфейсов компонент даже еще более вызывающе. Это требует хорошо образованных и опытных инженеров. Разработка действительно многоразовых высококачественных компонентов не может быть совершена «одним выстрелом»; она требует итеративного долговременного совершенствования, и потому является дорогостоящей.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote1.Phister.C.ComponentSoftware-1997art.p15}
\scnaddlevel{1}
    \scneq{\scnfileitem{The interface defines a standard for what component vendors have to provide and what component users can expect.}}
    %\scneq{\scnfileitem{Интерфейс определяет стандарт, которому производители компонентов обязаны следовать и которого пользователи вправе ожидать.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote2.Phister.C.ComponentSoftware-1997art.p15}
\scnaddlevel{1}
    \scneq{\scnfileitem{
        \begin{scnitemize}
            \item a standard that enables dynamic loading of components (dynamic link libraries, calling conventions)
            \item a standard programming interface
            \item a protection mechanism which prevents a component from illegally modifying the state of other components
            \item a way to share data between components without copying them back and forth, and without explicit conversions to or from linear byte streams
        \end{scnitemize}
    }}
    %\scneq{\scnfileitem{
    %    \begin{scnitemize}
    %        \item стандарт, который допускает динамическую загрузку компонентов (динамически загружаемые библиотеки, соглашения вызовов)
    %        \item стандартный программный интерфейс
    %        \item механизм защиты, который предотвращает нелегальные изменения состояний одних компонентов другими
    %        \item способ разделения данных между компонентами без их копирования взад-вперед и без явных преобразований в линейные потоки байт
    %    \end{scnitemize}
    %}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote.Phister.C.ComponentSoftware-1997art.p16}
\scnaddlevel{1}
    \scneq{\scnfileitem{While the syntax of an interface can be defined easily, clear semantics are elusive. Usually there is just an informal text describing what the interface means. Formal and semi-formal specification methods can help to make interfaces less ambiguous.}}
    %\scneq{\scnfileitem{В то время как синтаксис интерфейса может быть задан очень легко, ясная семантика трудноуловима. Обычно имеется простой неформальный текст, который описывает, что из себя представляет некоторый интерфейс. Формальные и полуформальные методы специфицирования могут помочь сделать интерфейсы менее противоречивыми.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote1.Phister.C.ComponentSoftware-1997art.p17}
\scnaddlevel{1}
    \scneq{\scnfileitem{...every component is required to interact with other components through their interfaces exclusively; this is a kind of universal contract, i.e., a law.}}
    %\scneq{\scnfileitem{...каждому компоненту нужно взаимодействовать с другими компонентами исключительно через их интерфейсы; это разновидность контракта, иначе говоря, закон для программиста.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote2.Phister.C.ComponentSoftware-1997art.p17}
\scnaddlevel{1}
    \scneq{\scnfileitem{An interface which defines too many inessential details will cause programmers to use them and to rely on their availability. This makes it impossible to change these details later, even though it may become strongly desirable to do so. Giving too many details is especially enticing if there already exists some complex but undocumented code, which is to be turned into a component.}}
    %\scneq{\scnfileitem{Интерфейс, который задает слишком много несущественных деталей, заставит программистов использовать их и допускать их истинность. Становится невозможным изменить эти детали позже, даже если это действительно потребуется. Особенно заманчиво приводить много деталей, когда уже существует сложный и недокументированный код, который должен быть включен в компонент.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote.Phister.C.ComponentSoftware-1997art.p18}
\scnaddlevel{1}
    \scneq{\scnfileitem{An object model defines the necessary rules to make components compatible on a binary level, such that components can interact on a particular machine even if they have been developed independently.}}
    %\scneq{\scnfileitem{Объектная модель определяет необходимые правила совместимости компонентов на уровне двоичного [машинного] кода, так что компоненты могут взаимодействовать на конкретной машине, даже если они разрабатывались независимо.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote.Phister.C.ComponentSoftware-1997art.p18-19}
\scnaddlevel{1}
    \scneq{\scnfileitem{ A component may use the services of another component. To achieve this, a developer only needs to know the used component's interface. Possibly, there does not even exist an actual implementation for this interface yet. An interface needs to be described in some way. A textual description of an interface is written in an interface description language (IDL). Ideally, this is just a subset of the programming language that the developer uses. However, a general object model is language-independent, and of course an IDL can only be a genuine subset of very similar programming languages.}}
    %\scneq{\scnfileitem{Компонент может пользоваться услугами другого компонента. Для этого разработчику надо всего лишь знать интерфейс используемого компонента. Возможно, для этого интерфейса пока еще даже нет реальной реализации. Интерфейс должен быть некоторым образом описан. Текстовое описание интерфейса записывается на языке описания интерфейса (IDL, interface description language). В идеале, он должен быть подмножеством того языка, который использует разработчик. Однако в целом объектная модель независима от языка, и конечно же, IDL может быть подмножеством только лишь очень похожих языков программирования.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote1.Phister.C.ComponentSoftware-1997art.p19}
\scnaddlevel{1}
    \scneq{\scnfileitem{An IDL description provides information about an object's interface to the developer. If possible, a compiler should use the same information to check whether the interface is used correctly. For this purpose, there often exists a binary format for interface descriptions in addition to the textual IDL format. The available collection of such binary descriptions is called the interface repository. It may just consist of a collection of so-called symbol files, or it may be stored in some kind of database.}}
    %\scneq{\scnfileitem{IDL-описание предоставляет разработчику информацию об интерфейсе объекта. Если возможно, компилятор должен использовать такую информацию для проверки того, корректно ли используется интерфейс. В этих целях часто существует двоичный формат для описание интерфейсов, в дополнение к текстовому IDL-формату. Доступный набор таких двоичных описаний называется репозиторием интерфейсов. Он может состоять просто из набора так называемых символьных файлов, или он может храниться в базе данных какого-либо рода.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote2.Phister.C.ComponentSoftware-1997art.p19}
\scnaddlevel{1}
    \scneq{\scnfileitem{When a component is compiled, the compiler needs to create a file containing the generated code. The format of such a file must be suitable for run-time loading, i.e., it must be a dynamic link library.}}
    %\scneq{\scnfileitem{Когда компонент компилируется, компилятор должен создать файл, который содержит сгенерированный код. Формат такого файла должен подходить для загрузки во время выполнения, то есть, он должен быть динамически загружаемой библиотекой.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote3.Phister.C.ComponentSoftware-1997art.p19}
\scnaddlevel{1}
    \scneq{\scnfileitem{At run-time, when a component for the first time needs the services of another component, this component is loaded. The loader first locates the code file of the component. Locating the code file may be straight-forward, e.g., the name of a component may directly determine the file system path to its code file. Alternatively, a configuration database may be consulted to determine the correct location of a suitable code file. This indirect approach is more flexible, but is more demanding in terms of system administration. The collection of code files or the corresponding database is called an implementation repository.}}
    %\scneq{\scnfileitem{Во время выполнения, когда компоненту первый раз потребовались услуги другого компонента, тот компонент загружается. Загрузчик сначала находит кодовый файл для компонента. Расположение кодового файла может быть очевидным, например, имя компонента может напрямую определять путь к его кодовому файлу в файловой системе. Другой вариант - текущее положение кодового файла может запрашиваться из конфигурационной базы данных. Косвенный подход более гибок, но более требователен в плане системного администрирования. Набор кодовых файлов или соответствующая база данных называются репозиторием реализации.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote4.Phister.C.ComponentSoftware-1997art.p19}
\scnaddlevel{1}
    \scneq{\scnfileitem{When the loader has successfully located a component and loaded its code into memory, it can check whether the loaded code really implements the interface that was requested, and whether the versions of the loaded component and its client are compatible. This check is of fundamental importance, because it is not acceptable that a version conflict leads to a crash some time later, leaving the user without clue as to the source of the problem. Some object models provide no adequate versioning mechanism and shift the burden of consistency checking partially or completely to the client component.}}
    %\scneq{\scnfileitem{Когда загрузчик успешно нашел компонент и загрузил его код в память, он может проверить, действительно ли загруженный код реализует запрошенный интерфейс, и совместимы ли версии загруженного компонента и его клиента. Такая проверка — насущная необходимость, поскольку нельзя допустить, чтобы кофликт версий привел некоторое время спустя к краху, и при этом пользователь мог бы только догадываться о причине проблемы. Некоторые объектные модели не предоставляют адекватного механизма контроля версий и перекладывают бремя проверки соответствия частично и полностью на клиентский компонент.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote5.Phister.C.ComponentSoftware-1997art.p19}
\scnaddlevel{1}
    \scneq{\scnfileitem{Once a component's code has been loaded and checked, instances of its classes can be created. For this purpose, the object model needs to define an allocation mechanism for objects. Some object models suggest an indirect approach to allocation, in order to gain additional flexibility. In particular, an object may be created by another object, a so-called factory object. A factory object may decide on its own how to allocate or how to initialize objects.}}
    %\scneq{\scnfileitem{Как только код компонента загружен и проверен, могут быть созданы экземпляры его классов. Для этих целей объектная модель должна обладать механизмом размещения объектов. Некоторые объектные модели предлагают косвенный подход к размещению, чтобы дать дополнительную гибкость. В частности, объект может создаваться другим объектом, так называемой фабрикой. Объект-фабрика может сам решать, как размещать и как инициализировать объекты.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote6.Phister.C.ComponentSoftware-1997art.p19}
\scnaddlevel{1}
    \scneq{\scnfileitem{When an object thus finally has been created and made accessible to others, its methods can be called. A method call is a procedure call performed indirectly via an object, so that different objects can lead to different code being called. Typically, an object contains a pointer to a table of procedure pointers. Each element of the table corresponds to one method of the object. A method call then simply becomes an indirect procedure call via the object's method table. Usually the calling conventions of the underlying operating system are used for these procedure calls.}}
    %\scneq{\scnfileitem{После того, как объект был создан и стал доступен для других, можно вызывать его методы. Вызов метода — это вызов процедуры, который выполняется не напрямую, а через объект, так что различные объекты могут приводить к вызову различного кода. Обычно объект содержит указатель на таблицу указателей на процедуры. Каждый элемент этой таблицы соответствует одному методу объекта. Поэтому вызов метода - всего лишь непрямой вызов процедуры через таблицу методов объекта. Обычно для этих вызовов используются соглашения вызовов базовой операционной системы.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote1.Phister.C.ComponentSoftware-1997art.p20}
\scnaddlevel{1}
    \scneq{\scnfileitem{ Polymorphism is one of the fundamental properties of any object-oriented or component-oriented system. In a program, some interface supported by an object may be known at compile-time. This is called its static type. But an object may reveal additional capabilities, i.e., an extended interface, at run-time. Depending on the object's dynamic type, these capabilities may differ. This is called polymorphism ("many shapes"). An object model needs to provide a means to gain access to these optional capabilities if and only if they are available. An object-oriented programming language defines language constructs such as type extension (also known as subtyping or interface inheritance), type tests, or type guards (i.e., safe type casts) for this purpose. The object model must provide similar functionality. Without polymorphism, a system would not be extensible.}}
    %\scneq{\scnfileitem{Полиморфизм — одно из главных качеств любой объектно-ориентированной или компонентно-ориентированной системы. Некотрый интерфейс, поддерживаемый объектом, может быть известен во время компиляции. Он называется его статическим типом. Но объект может приобретать дополнительные возможности, то есть, расширять свой интерфейс, во время выполнения. В зависимости от динамического типа объекта эти возможности могут отличаться. Это называется полиморфизмом («много форм»). Объектная модель должна обеспечить средства, с помощью которых можно получить доступ к таким дополнительным возможностям, если и только если они доступны. Объектно-ориентированный язык программирования в этих целях задает языковые конструкции, такие как расширение типа (также извествное как субтипизация или наследование интерфейса), проверки типа или охрана типа (то есть, безопасные преобразования между типами). Объектная модель может предоставлять похожую функциональность. Без полифморфизма система не может быть расширяемой.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote2.Phister.C.ComponentSoftware-1997art.p20}
\scnaddlevel{1}
    \scneq{\scnfileitem{When an object is no longer used, i.e., when it is no longer being referenced from the outside, it must be deallocated to free the memory that it occupies. In a component world, the objects that a component makes accessible to the outside may become referenced by any number of other objects that it doesn't even know about. There must be rules that establish who must deallocate a given object, and when. For example, the object that releases the last remaining reference to another object could deallocate it. To determine whether an object owns the last reference to another one, a mechanism is needed that helps tracking references, e.g., a reference count in each object which counts the number of currently existing references to it. When the count goes down to zero, the object's memory can be freed. Correct usage by all components is critical for such rules to work. In a closed application, incorrect memory management is one of the most expensive sources of errors; but at least you know who to blame if the application crashes. In an open component world, one malfunctioning component can cause others to crash, which makes it difficult to pinpoint the culpable vendor. Thus memory management in a component software environment is a fundamentally more critical issue than for monolithic software. Ideally, the rules and mechanisms defined by an object model should be sufficiently simple, complete and clear that they can be automated; i.e., it should be possible to relieve the developer from manual deallocation, by providing an automatic garbage collector. Automatic garbage collection in an open world is no luxury, it is a necessity.}}
    %\scneq{\scnfileitem{Если объект больше не используется, то есть, на него больше нет внешних ссылок, он должен быть уничтожен, чтобы освободилась занимаемая им память. В компонентных системах на объект, который компонент предоставляет вовне, ссылаются какие-либо другие объекты, о которых сам объект ничего не знает. Поэтому должны существовать правила, которые указывают, кто и когда должен уничтожить данный объект. Например, это может сделать другой объект, у которого осталась последняя ссылка на данный. Для определения того момента, когда ссылка на объект стала последней, необходим механизм трассировки ссылок, например, счетчик ссылок в каждом объекте, который подсчитывает количество текущих ссылок на него. Когда количество становится равным нулю, память объекта может быть освобождена. Для того, чтобы такие правила работали, критически важно их правильное использование всеми компонентами. В замкнутых приложениях неправильная работа с памятью является самым главным источником ошибок; но вы, по крайней мере, знаете, кто виноват в произошедшем сбое. В открытых компонентных системах один неправильно работающий компонент может привести к краху всю систему, при этом сложно определить виновного производителя. Поэтому управление памятью в компонентной программной среде является принципиально более важным вопросом, чем в монолитном ПО. В идеале правила и механизмы, вводимые объектной моделью, должны быть достаточно простыми, полными и ясными, чтобы их можно было автоматизировать, то есть, освободить разработчика от ручной работы, предоставив автоматический сборщик мусора. Автоматический сборщик мусора в открытых системах - это не роскошь, а необходимость.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote3.Phister.C.ComponentSoftware-1997art.p20}
\scnaddlevel{1}
    \scneq{\scnfileitem{An object model that supports distributed objects must define a message format, which describes the byte streams produced by a remote method call. The caller of a method is called the client, the callee is called the server. In the most general scenario, the server object is implemented on another machine than the client. From a developer's perspective, the client can directly call a server object's methods. In reality, the client only interacts with a proxy object, which is a local representation of the true object implementation on the remote server machine. In most implementations, a proxy, as well as its server-side counterpart, can be generated automatically out of the object's interface.}}
    %\scneq{\scnfileitem{Объектная модель, которая поддерживает распределенные объекты, должна определять формат сообщений, который описывает потоки байт, порождаемые удаленным вызовом методов. Того, кто вызывает метод, называют клиентом, того, чей метод вызывают, — сервером. По самому общему сценарию серверный объект и клиент выполняются на разных машинах. С точки зрения разработчика клиент может напрямую вызывать методы серверного объекта. В реальности клиент взаимодействует всего лишь с прокси объектом, который является локальным представителем настоящего объекта, работающего на удаленной серверной машине. В большинстве реализаций прокси-объект, также как и его аналог на стороне сервера, могут генерироваться автоматически из интерфейса объекта.}}
\scnaddlevel{-1}



% https://books.google.by/books?id=U896iwmtiagC
\scnheader{Szyperski.C.CompSoftBOOP-2002book}
\scnrelfrom{тип}{книга}
\scnrelfromlist{ключевой знак}{компонент;компонентное проектирование;компоненто-ориентированное программирование}
\scntext{аннотация}{Книга посвящена посвящена компонентному проектированию, как способу повторно использовать уже разработанное программное обеспечение.}

\scnrelfrom{цитата}{Quote.Szyperski.C.CompSoftBOOP-2002book.p10}
\scnaddlevel{1}
    \scneq{\scnfileitem{A software component is what is actually deployed – as an isolatable part of a system – in a component-based approach. Contrary to frequent claims, objects are almost never sold, bought, or deployed.}}
    %\scneq{\scnfileitem{Программный компонент -- то, что непосредственно разворачивается -- как изолируемая часть системы -- в компонентно-ориентированном подходе. Вопреки частым утверждениям, объекты почти никогда не продаются, не покупаются и не разворачиваются.}}
    \scnrelfromset{сравнение}{компонентное программное обеспечение;объектно-ориентированное программное обеспечение}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote1.Szyperski.C.CompSoftBOOP-2002book.p11}
\scnaddlevel{1}
    \scneq{\scnfileitem{...a component could just as well use some totally different implementation technology, such as pure functions or assembly language, and look not at all object-oriented from the inside.}}
    %\scneq{\scnfileitem{...при разработке компонента также может быть использована совсем иная технология, такая как чистые функции или язык ассемблера, которые не имеют ничего общего с объектно-ориентированностью изнутри.}}
    \scnrelfromset{сравнение}{компонентное программное обеспечение;объектно-ориентированное программное обеспечение}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote2.Szyperski.C.CompSoftBOOP-2002book.p11}
\scnaddlevel{1}
    \scneq{\scnfileitem{The definition [of object] does not include notions of independence or late composition.}}
    %\scneq{\scnfileitem{Определение [объекта] не включает в себя независимости или компонуемости.}}
    \scnrelfromset{сравнение}{компонентное программное обеспечение;объектно-ориентированное программное обеспечение}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote1.Szyperski.C.CompSoftBOOP-2002book.p36}
\scnaddlevel{1}
    \scneq{\scnfileitem{For a component to be independently deployable, it needs to be well separated from its environment and other components.}}
    %\scneq{\scnfileitem{Для того, чтобы компонент можно было развернуть независимо, он должен быть отделён от своего окружения и других компонентов.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote2.Szyperski.C.CompSoftBOOP-2002book.p36}
\scnaddlevel{1}
    \scneq{\scnfileitem{...it [component] needs to come with clear specifications of what it requires and provides. In other words, a component needs to encapsulate its implementation and interact with its environment by means of well-defined interfaces.}}
    %\scneq{\scnfileitem{...он [компонент] должен поставляться с чёткой спецификацией того, что он требует и предоставляет. Другими словами, компонент должен скрывать свою имплементацию и взаимодействовать с окружением при помощи чётко определённых интерфейсов.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote3.Szyperski.C.CompSoftBOOP-2002book.p36}
\scnaddlevel{1}
    \scneq{\scnfileitem{...a component should not have any (externally) observable state.}}
    %\scneq{\scnfileitem{...компонент не должен иметь наблюдаемого (извне) состояния.}}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote4.Szyperski.C.CompSoftBOOP-2002book.p36}
\scnaddlevel{1}
    \scneq{\scnfileitem{...it makes little sense to have multiple copies [of a component] in the same operating system process as these would be mutually indistinguishable anyway. In other words, in any given process (or other loading context), there will be at most one copy of a particular component.}}
    %\scneq{\scnfileitem{...не имеет смысла иметь несколько копий [компонента] в одной и той же операционной системе, поскольку они в любом случае будут фактически неотличимы. Другими словами, в любом процессе (или ином контексте), не должно быть более одной копии конкретного компонента.}}
\scnaddlevel{-1}

\scnheader{USGenServAdm.2.101.Definitions-reg}\\
\scnrelfrom{тип}{закон}\\
\scnrelfrom{цитата}{Quote.USGenServAdm.2.101.Definitions-reg}
\scnaddlevel{1}
    \scneq{\scnfileitem{
    Commercially available off-the-shelf (COTS) item means any item of supply (including construction material) that is
    \begin{scnitemize}
        \item A commercial product (as defined in paragraph (1) of the definition of “commercial product” in this section);
        \item Sold in substantial quantities in the commercial marketplace; and
        \item Offered to the Government [customer], under a contract or subcontract at any tier, without modification, in the same form in which it is sold in the commercial marketplace; 
    \end{scnitemize}
    }}
\scnaddlevel{-1}

\scnheader{Khan.A.PerspecStudyISFCBD-2015art}
\scnrelfrom{тип}{статья}
\scntext{аннотация}{Nowadays, researchers envisage an Intelligent ComponentOriented Software Development methodology which is an amalgam of the two approaches resulting in more flexible, reusable and customizable agent components. This helps in pushing forward the development timelines and quality expectations to newer heights. In this paper we mainly analyzed various states of art intelligent component-oriented software development techniques and studied the research gap in the component selection processes. Recommendations for future research direction for Intelligent Component-Oriented Software Development are also highlighted in this paper.}
% Multi-agent control, Component Based Development, Agentbased modeling, Self-adaptive systems
\scnrelfromlist{ключевой знак}{
    мультиагентные системы;
    компоненто-ориентированное проектирование;
    агенто-ориентированное проектирование;
    самоадаптирующиеся системы
}
\scnrelfrom{цитата}{Quote1.Khan.A.PerspecStudyISFCBD-2015art-p.11}
\scnaddlevel{1}
    \scneq{\scnfileitem{It is very difficult to guess how the components behave under different conditions and environments as mostly COTS software comes up as a black box with limited access.}}
\scnaddlevel{-1}
\scnrelfrom{цитата}{Quote2.Khan.A.PerspecStudyISFCBD-2015art-p.11}
\scnaddlevel{1}
    \scneq{\scnfileitem{It is also difficult to map user requirement to the component based architecture and generally there is a need for a process which fully customized the component as per the customer requirement.}}
\scnaddlevel{-1}
\scnrelfrom{цитата}{Quote.Khan.A.PerspecStudyISFCBD-2015art-p.11-12}
\scnaddlevel{1}
    \scneq{\scnfileitem{In order to developed application from components or tailor components to a new situation, efforts are required to build wrappers and the glue between components, since most of the COTS software lacks in plug and play technique and developer has to build wrappers for component integration. Further, wrappers need to be maintained as the system evolves.}}
\scnaddlevel{-1}
\scnrelfrom{цитата}{Quote1.Khan.A.PerspecStudyISFCBD-2015art-p.12}
\scnaddlevel{1}
    \scneq{\scnfileitem{Components are packaged and delivered in many different forms (example: function libraries, off-the shelf applications and frameworks).}}
\scnaddlevel{-1}
\scnrelfrom{цитата}{Quote2.Khan.A.PerspecStudyISFCBD-2015art-p.12}
\scnaddlevel{1}
    \scneq{\scnfileitem{Most component integration processes suffer from inflexibility by a lack of component evaluation schemes. This problem is often compounded by a lack of interoperability standards between component frameworks and adequate vendor support.}}
\scnaddlevel{-1}

\scnheader{Maybury.M.IntellUserInterfIntro-1998art}
\scnrelfrom{тип}{статья}
\scnrelfromlist{ключевой знак}{пользовательский интерфейс;интеллектуальный пользовательский интерфейс}
\scntext{аннотация}{В этом введении описывается потребность в интеллектуальных пользовательских интерфейсах (IUI), определяется основная терминология, используемая в этой области. После описания теоретических основ интеллектуальных пользовательских интерфейсов в этом вводном разделе описываются современное состояние дел и обобщает структуру и содержание этой коллекции, в которой рассматриваются некоторые остающиеся фундаментальные проблемы в этой области.}

\lscnquote{Quote1.Maybury.M.IntellUserInterfIntro-1998art.p2}{Intelligent user interfaces (IUIs) are human-machine interfaces that aim to improve the efficiency, effectiveness, and naturalness of human-machine interaction by representing, reasoning, and acting on models of the user, domain, task, discourse, and media (e.g., graphics, natural language, gesture). As a consequence, this interdisciplinary area draws upon research in and lies at the intersection of human-computer interaction, ergonomics, cognitive science, and artificial intelligence and its subareas (e.g., vision, speech and language processing, knowledge representation and reasoning, machine learning/knowledge discovery, planning and agentmodeling, user and discourse modeling). }

\lscnquote{Quote1.Maybury.M.IntellUserInterfIntro-1998art.p3-4}{The "intelligence" in IUIs that distinguishes them from traditional interfaces... it [IUI] includes mechanisms that perform automated media analysis, design, and interaction management... Traditional user interfaces distinguish only three models: presentation, dialog, and application. Refinements beyond these three models that are found in IUIs include explicit models of the user, discourse and domain, input analysis and output generation, and mechanisms to manage the interaction, such as fusing and interpreting imprecise, ambiguous, and/or inaccurate input, controlling the dialog progression, or tailoring presentation output to the current situation. Research so far has shown that it is possible to adapt many of the fundamental concepts developed to date in computational linguistics and discourse theory in such a way that they become useful for multimedia user interfaces as well. In particular, semantic and pragmatic concepts like communicative acts, coherence, focus, reference, discourse model, user model, implicature, anaphora, rhetorical relations, and scope ambiguity take on an extended meaning in the context of multimodal communication... artificial intelligence has much to contribute to user interfaces, including the use of knowledge representations for model-based interface development tools. Architecture of Intelligent User Interfaces application of plan generation and recognition in dialog management, the application of temporal and spatial reasoning to media coordination, the use of user models to tailor interaction, and so on.}

\scnheader{Ehlert.P.IntellUserInterfIAS-2003art}
\scnrelfrom{тип}{статья}
\scnrelfromlist{ключевой знак}{интеллектуальный пользовательский интерфейс; IUI; intelligent user interface; адаптивный интерфейс; взаимодействие человек-компьютер; модель пользователя; распознавание плана; мультимодальное взаимодействие; интеллектуальные агенты; software usability; искусственный интеллект}
\scntext{аннотация}{Этот отчет является частью исследования литературы по интеллектуальным пользовательским интерфейсам. Цель этого отчета состоит в том, чтобы представить область, объяснить концепции и предоставить глобальный обзор существующих приложений (исследований) с интеллектуальным пользовательским интерфейсом. Этот отчет предназначен для ученых-компьютерщиков или опытных пользователей компьютеров. Чтобы полностью понять
отчет, некоторые базовые знания об искусственном интеллекте могут быть полезны.}
\lscnquote{Quote1.Ehlert.P.IntellUserInterfIAS-2003art.p2}{
\begin{scnitemize}
        \item \textbf{Creating personalized systems}\\
        No two persons are the same and people have different habits, preferences, and working methods and environment. An intelligent interface that takes these differences into account can provide a personalized method of interaction. The interface knows the user and can use that knowledge in its communication with the user.
        \item \textbf{Information overflow or filtering problems}\\
        Finding the right information on your computer or on the Internet can be like looking for a needle in a haystack. Intelligent interfaces can reduce the information overload that often results from finding information in large databases or complex systems. By filtering out irrelevant information, the interface can reduce the cognitive load on the user. In addition, the IUI can propose new and useful information sources not known to the user.
        \item \textbf{Providing help on using new and complex programs}\\
        Computer systems can be very complicated to work with when you first start to use them. As you struggle to get to know and understand a new program, new software versions or updates may appear that include new functionality. Many computer users fail to keep up with these developments. Intelligent help systems can detect and correct user misconceptions, explain new concepts, and provide information to simplify tasks.
        \item \textbf{Taking over tasks from the user}\\
        An IUI can also look at what you are doing, understand and recognize your intent, and take over some of your tasks completely, allowing you to focus on other things.
        \item \textbf{Other forms of interaction}\\
        Currently, the most common interaction devices are the keyboard and the mouse. IUIresearch looks at other forms of human-computer interaction (e.g. speech or gestures). By providing multiple forms of interaction, people with a disability will be able to use computers more easily. 
    \end{scnitemize}
}
\lscnquote{Quote1.Ehlert.P.IntellUserInterfIAS-2003art.p4}{Intelligent input technology uses innovative techniques to get input from a user. These techniques include natural language, gesture tracking and recognition, facial expression recognition, and gaze tracking among others; }
\lscnquote{Quote2.Ehlert.P.IntellUserInterfIAS-2003art.p4}{User modeling covers techniques that allow a system to maintain or infer knowledge about
a user based on the received input}
\lscnquote{Quote3.Ehlert.P.IntellUserInterfIAS-2003art.p4}{User adaptivity includes all techniques that allow the communication between human and machine to be adapted to different users and different situations for example, machine learning or context awareness}
\lscnquote{Quote4.Ehlert.P.IntellUserInterfIAS-2003art.p4}{Explanation generation covers all techniques that allow a system to explain its results to a user for example, speech output, intelligent interface agents, tactile feedback in a virtual reality environment. }
\lscnquote{Quote5.Ehlert.P.IntellUserInterfIAS-2003art.p4}{To achieve personalization, IUIs often include a representation of a user. These user models log data about the userís behavior, knowledge, and abilities. New knowledge about the user can be inferred based on the input and interaction history of the user with the system.}
\lscnquote{Quote1.Ehlert.P.IntellUserInterfIAS-2003.p5}{An often-made mistake is to confuse an IUI with an intelligent system. A system exhibiting some form of intelligence is not necessarily an intelligent interface. There are many intelligent systems with very simple non-intelligent interfaces and the fact that a system has an intelligent interface does not say anything about the intelligence of the underlying system}
\lscnquote{Quote1.Ehlert.P.IntellUserInterfIAS-2003.p8}{
\begin{scnitemize}
    \item An adaptive user interface must be developed in parallel with the application. This is necessary since the designer continuously needs to focus on the system parts that need to be adapted.
    \item Do not disturb the user's interaction. It should always be possible for the user to ignore the proactive actions of the IUI. Suggest rather than act.
    \item Operate in real-time. Much of the benefit of an IUI comes from acting while the user is busy working with the system.
    \item Take advantage of the user's think time. When the user is thinking about what input to provide next, the IUI can take advantage of the available processing time, so it does not risk slowing down the userís interaction with the system.
    \item Watch what the user is doing. Take advantage of ìfreeî information implicit in user actions.
    \item Allow the user to choose his personal interaction style. Different users like different interface styles and some techniques may be distracting or confusing to some users. 
\end{scnitemize}}
\lscnquote{Quote1.Ehlert.P.IntellUserInterfIAS-2003.p9-10}{
\begin{scnitemize}
    \item An adaptive system is unpredictable and less transparent than a DM interface. If a system can adapt its response and does not give the same response twice given the same input, then the system becomes unpredictable. This will hinder the userís comprehension of the system, making it impossible for him to do a successful action twice. 
    \item Users are not in control anymore. An IUI can make decisions for the user, thus placing the user outside the control loop.
    \item IUIs often make mistakes. Many IUI systems use trail and error to determine a userís intent or preferences. Therefore users need to give feedback to the system or even resolve the mistakes made by the system.
    \item Simulated intelligence and adaptivity increases the risk of the user thinking that computer can do things that it cannot, thus creating false expectations. Especially with anthropomorphic agents users may believe they can interact with the IUI just as with another person.
    \item Who is responsible? If a system can make decisions on its own, who is responsible for the actions: the programmer of the system, the user, or the system itself?
    \item What about the privacy and thrust of the user? What happens to the user profile that is created and maintained by an IUI? Can you guarantee that it is safe and will not be misused?
\end{scnitemize}}
\lscnquote{Quote1.Ehlert.P.IntellUserInterfIAS-2003art.p13}{Speech recognition; conversion of an input speech utterance into a string of words. }
\lscnquote{Quote2.Ehlert.P.IntellUserInterfIAS-2003art.p13}{Language understanding; analysis of the string of words (as much as possible) to extract a meaning representation for the recognized utterance.}
\lscnquote{Quote3.Ehlert.P.IntellUserInterfIAS-2003art.p13}{Dialogue management; controlling the interaction or dialogue between the system and the user, which includes coordination of other components of the system.}
\lscnquote{Quote4.Ehlert.P.IntellUserInterfIAS-2003art.p13}{Database query; retrieving the information requested by the user. }
\lscnquote{Quote5.Ehlert.P.IntellUserInterfIAS-2003art.p13}{Response generation; specification of the text that is to be the output message of the system.}
\lscnquote{Quote6.Ehlert.P.IntellUserInterfIAS-2003art.p13}{Speech output; actual generation of the output message using text-to-speech synthesis or prerecorded sentences.}
\lscnquote{Quote1.Ehlert.P.IntellUserInterfIAS-2003art.p17}{People use gestures a lot when talking, often subconsciously. The most often-used gestures are those associated with speech, for example pointing to an object that one is referring to. This kind of gesturing is called gesticulation. Gestures that function independent of speech are called autonomous gestures, for example sign language.}
\lscnquote{Quote2.Ehlert.P.IntellUserInterfIAS-2003.p17}{Symbolic gestures have a (single) verbal and often cultural dependant meaning, for example the OK sign, or sign language for deaf people.}
\lscnquote{Quote3.Ehlert.P.IntellUserInterfIAS-2003.p17}{Deictic gestures are made by pointing or motioning to direct attention to some object or
event.}
\lscnquote{Quote1.Ehlert.P.IntellUserInterfIAS-2003.p18}{Iconic gestures are gestures that display information about the size, shape or orientation of objects, spatial relations, and actions, for example using hands to indicate the size of fish that one caught).}
\lscnquote{Quote2.Ehlert.P.IntellUserInterfIAS-2003.p18}{Pantomimic gestures consist of manipulating an invisible imaginary object or tool, for example making a fist and moving to indicate a hammer).}
\lscnquote{Quote3.Ehlert.P.IntellUserInterfIAS-2003.p18}{People use their eyes with very little conscious effort. Most of the time, we automatically look at the object we are working on. To see an object clearly, it is necessary to move your eyes so that the object appears on the fovea, a small area at the center of the retina. The fovea covers approximately one degree of visual arc. Because of this, a personís eye position provides a rather good indication (to within the one-degree width of the fovea) of a personís focus point of attention on a display.}
\lscnquote{Quote1.Ehlert.P.IntellUserInterfIAS-2003.p19}{A problem with speech recognition based on an acoustic signal, is that it functions very badly when there is a lot of noise. The reason for this is that it is very hard to distinguish the speakerís voice from other sounds. With lip reading the idea is that the computer tries to determine what someone is saying just by looking at the personís lip movements, like a deaf person. By analyzing video images of the mouth and using geometric features, such as the width and height of the lips, the most probable sound (phoneme) can be determined.}
\lscnquote{Quote1.Ehlert.P.IntellUserInterfIAS-2003art.p20}{With multimodal interfaces, the idea is to use multiple input channels in human-computer interaction. Instead of only speech or text as input, the system can use image recognition to look at a userís face or gestures. This way, information from one mode of interaction can complement the information received from another mode. Multimodal interfaces try to integrate speech, written text, body language, gestures, eye or lip movements and other forms of communication in order to better understand the user and to communicate more effectively. Of course, the choice of the used modalities in multimodal interfaces depends very much on the application of the system. When users can choose from multiple modalities to interact with a system, the system has the potential to be accessible to a broader range of users, for example people with disabilities. Also, multimodal user interfaces are much more robust than normal interfaces, at least in theory. Processing input from one modality can be simplified by using information from another and the user can choose the modality that is the least error prone given the circumstances.}
\lscnquote{Quote2.Ehlert.P.IntellUserInterfIAS-2003art.p20}{The main bottleneck in multimodal interfaces is to combine the information gathered from the used modalities in real time. All multimodal interfaces need some form of input coordination or fusion system to synchronize related input.}
\lscnquote{Quote3.Ehlert.P.IntellUserInterfIAS-2003art.p20}{Feature-level fusion is appropriate when combining two related modalities, such as speech processing and lip movements. The advantage of feature-level fusion is the improved recognition rate due to the complementary nature of both input channels (mutual disambiguation). A drawback of this tight integration of input processing is that the system has to be retrained when the one of the input modalities is changed. In addition, training a system with multiple modalities using simultaneous input is much more difficult than training one modality at the time.}
\lscnquote{Quote1.Ehlert.P.IntellUserInterfIAS-2003art.p20-21}{Semantic-level fusion is much easier. It does not have the benefit of direct complementary information, but a semantic-level fusion system is much easier to create and extend. Such as system can use multiple off-the-shelf recognition techniques and new modalities can easily be added later. Semantic-level integration is usually done either through unification of existing data or by looking for missing data. The latter is called frame-based integration, where the systems tries to fill missing data slots.}
\lscnquote{Quote1.Ehlert.P.IntellUSerInterfIAS-2003.p36}{
\begin{scnitemize}
    \item Cognitive theory and empirical science underpinnings. A better understanding is required of the unique linguistic and performance characteristics of natural communication modalities (speech, gesture, gaze and facial expressions) and of how these modalities can be combined best.
    \item New multimodal interface concepts. Current research on multimodal interfaces has focused mainly on natural language processing, pen-based gestures. Additional input such as body motion and facial expressions should be studied.
    \item Multimodal language and dialogue processing. A general theory of conversational interaction is needed that deals with intent representation for non-speech modalities.
    \item Error handling techniques. Graceful error handling is still a problem in multimodal interfaces and mutual disambiguation between signals can be improved. Also the impact of a third or more modalities on the error rate should be studied, as well as performance under
    difficult (mobile) environments.
    \item Adaptive multimodal architectures. Multimodal architectures are hardly adaptive and adapting to a specific user or environment can increase the recognition of input processing, as well as provide more flexibility and ease of use for the user.
    \item Multi-device multi-user ubiquitous computing. In the future, mobile computing will become more important, so we need to look at the role of multimodal interfaces in that area. In addition, when multiple users are interacting together, for example via the Internet, interfaces need to take multiple input from remote devices into account.
    \item Multimodal research infrastructure. Supporting tools for multimodal interface research should be developed. This includes; semi-automatic simulation methods for empirical data collection and prototyping of new systems, automated tools for collecting and analyzing multimodal corpora, novel metrics for evaluating multimodal systems, and software tools that support the rapid creation of next-generation multimodal applications. 
\end{scnitemize}}

\scnheader{Microsoft.WindowsDA-2011el}
\scnrelfrom{тип}{электронный ресурс}
\scnrelfromlist{ключевой знак}{интерфейс;компоненты интерфейса}
\scntext{аннотация}{Руководство по проектированию и примеры кода пользовательского интерфейса для создания процессов взаимодействия с приложениями для Windows.}

\scntext{url}{https://docs.microsoft.com/en-US/windows/apps/design}

\scnrelfrom{цитата}{Quote1.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{Use an AutoSuggestBox to provide a list of suggestions for a user to select from as they type.}}
    %\scneq{\scnfileitem{Используйте AutoSuggestBox, чтобы предоставить список предложений, из которых пользователь по мере ввода текста может выбрать нужное.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/auto-suggest-box}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote2.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{A BreadcrumbBar provides the direct path of pages or folders to the current location. It is often used for situations where the user's navigation trail (in a file system or menu system) needs to be persistently visible and the user may need to go back to a previous location.}}
    %\scneq{\scnfileitem{Панель навигации предоставляет прямой путь к страницам или папкам в текущее расположение. Он часто используется для ситуаций, когда путь навигации пользователя (в файловой системе или системе меню) должен быть постоянно видимым, и пользователю может потребоваться вернуться к предыдущему расположению.}}
    \scntext{url}{https://docs.microsoft.com/en-US/windows/apps/design/controls/breadcrumbbar}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote3.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{The calendar date picker is a drop down control that's optimized for picking a single date from a calendar view where contextual information like the day of the week or fullness of the calendar is important. You can modify the calendar to provide additional context or to limit available dates.}}
    %\scneq{\scnfileitem{Управляющий элемент выбора даты в календаре — это раскрывающийся элемент управления, оптимизированный для выбора отдельной даты в представлении календаря, когда важна контекстная информация, например день недели или заполненность календаря. Вы можете изменить календарь таким образом, чтобы обеспечить дополнительный контекст или ограничить доступные даты.}}
    \scntext{url}{https://docs.microsoft.com/en-US/windows/apps/design/controls/calendar-date-picker}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote4.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{A calendar view lets a user view and interact with a calendar that they can navigate by month, year, or decade. A user can select a single date or a range of dates. It doesn't have a picker surface and the calendar is always visible.}}
    %\scneq{\scnfileitem{Представление календаря позволяет пользователю просматривать календарь и взаимодействовать с ним, перемещаясь по месяцам, годам и десятилетиям. Пользователь может выбрать отдельную дату или диапазон дат. Не имеет поверхности выбора, и календарь всегда виден.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/calendar-view}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote5.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{A color picker is used to browse through and select colors.}}
    %\scneq{\scnfileitem{Палитра используется для просмотра и выбора цвета.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/color-picker}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote6.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{Use a combo box (also known as a drop-down list) to present a list of items that a user can select from. A combo box starts in a compact state and expands to show a list of selectable items. A list box is similar to a combo box, but is not collapsible/does not have a compact state.}}
    %\scneq{\scnfileitem{Поле со списком (также известное как раскрывающийся список) позволяет представить список элементов, из которых пользователь может выбирать. Сначала поле со списком представлено в компактном состоянии, а затем развертывается для отображения списка элементов, доступных для выбора. Поле со списком похоже на поле со списком, но не свертывается или не имеет компактного состояния.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/combo-box}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote7.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{Command bars provide users with easy access to your app's most common tasks. Command bars can provide access to app-level or page-specific commands and can be used with any navigation pattern.}}
    %\scneq{\scnfileitem{Панели команд предоставляют пользователям удобный доступ к самым распространенным задачам приложения. Панели команд могут предоставлять доступ к командам приложения или страниц, работая с любым шаблоном навигации.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/command-bar}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote8.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{The contact card displays contact information, such as the name, phone number, and address, for a Contact. The contact card also lets the user edit contact info.}}
   % \scneq{\scnfileitem{Карта контакта отображает контактные данные, такие как имя, номер телефона и адрес контакта. Карточка контакта также позволяет пользователю редактировать контактные данные.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/contact-card}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote9.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{Dialog controls are modal UI overlays that provide contextual app information. They block interactions with the app window until being explicitly dismissed. They often request some kind of action from the user.}}
    %\scneq{\scnfileitem{Диалоговые элементы управления — это модальные наложения пользовательского интерфейса, которые предоставляют контекстную информацию о приложении. Они блокируют взаимодействие с окном приложения, пока пользователь явно их не закроет. Они часто требуют от пользователя совершения каких-либо действий.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/dialogs-and-flyouts/dialogs}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote10.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{Content links provide a way to embed rich data in your text controls, which lets a user find and use more information about a person or place without leaving the context of your app.}}
    %\scneq{\scnfileitem{Ссылки на содержимое позволяют вставлять в текстовые элементы управления форматированные данные. Благодаря этому пользователь может находить и использовать больше информации о людях и местах, не покидая вашего приложения.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/content-links}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote11.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{The date picker gives you a standardized way to let users pick a localized date value using touch, mouse, or keyboard input.}}
    %\scneq{\scnfileitem{Элемент выбора даты — это стандартизованный способ, позволяющий пользователям выбирать локализованное значение даты с помощью сенсорного ввода, мыши или клавиатуры.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/date-picker}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote12.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{The Expander control lets you show or hide less important content that's related to a piece of primary content that's always visible.}}
    %\scneq{\scnfileitem{Элемент управления "Расширитель " позволяет отображать или скрывать менее важное содержимое, связанное с частью основного содержимого, которое всегда отображается.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/expander}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote13.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{Use a flip view for browsing images or other items in a collection, such as photos in an album or items in a product details page, one item at a time.}}
    %\scneq{\scnfileitem{Используйте представление пролистывания для просмотра изображений или других элементов в коллекции, например фотографий в альбоме или элементов на странице описания продукта. Каждый раз отображается один элемент.}}
    \scntext{url}{https://docs.microsoft.com/en-US/windows/apps/design/controls/flipview}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote14.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{A flyout is a light dismiss container that can show arbitrary UI as its content. Flyouts can contain other flyouts or context menus to create a nested experience.}}
    %\scneq{\scnfileitem{Всплывающий элемент — это контейнер с возможностью исчезновения, который отображает в качестве содержимого произвольный пользовательский интерфейс. Всплывающие элементы могут содержать другие вложенные всплывающие элементы или контекстные меню.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/dialogs-and-flyouts/flyouts}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote15.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{A form is a group of controls that collect and submit data from users. Forms are typically used for settings pages, surveys, creating accounts, and much more.}}
    %\scneq{\scnfileitem{Форма — это группа элементов управления, которые собирают данные пользователей и отправляют их. Формы обычно используются для страниц параметров, опросов, создания учетных записей и многого другого.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/forms}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote16.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{Hyperlinks navigate the user to another part of the app, to another app, or launch a specific uniform resource identifier (URI) using a separate browser app.}}
    %\scneq{\scnfileitem{Гиперссылки используются для перехода в другую часть приложения, в другое приложение либо по указанному универсальному коду ресурса (URI) в отдельном приложении браузера.}}
    \scntext{url}{https://docs.microsoft.com/en-us/windows/apps/design/controls/hyperlinks}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote17.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{Use the InkCanvas when you need to enable basic inking features in your app}}
    %\scneq{\scnfileitem{Элемент управления рукописным вводом позволяет включить в приложении базовые функции рукописного ввода}}
    \scntext{url}{https://docs.microsoft.com/en-US/windows/apps/design/controls/inking-controls}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote18.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{Menu flyouts are used in menu and context menu scenarios to display a list of commands or options when requested by the user.}}
    %\scneq{\scnfileitem{Всплывающие элементы меню используются в сценариях меню и контекстного меню для отображения списка команд или параметров, запрашиваемых пользователем.}}
    \scntext{url}{https://docs.microsoft.com/en-US/windows/apps/design/controls/menus}
\scnaddlevel{-1}

\scnrelfrom{цитата}{Quote19.Microsoft.WindowsDA-2011el}
\scnaddlevel{1}
    \scneq{\scnfileitem{You can show a map in light dismissable window called a map placecard or in a full featured map control.}}
    %\scneq{\scnfileitem{Карту можно показывать во всплывающем окне, называемом карточкой места, или в полнофункциональном элементе управления с картой.}}
    \scntext{url}{https://docs.microsoft.com/en-US/windows/uwp/maps-and-location/display-maps}
\scnaddlevel{-1}

\end{small}
\end{SCn}