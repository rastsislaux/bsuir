def input_set(): # Пользователь задает  множество
    print("Введите мощность множества: ", end="")
    x_card = int(input()) # Пользователь вводит мощность множества
    print("Введите элементы множества:")
    elements = [int(i) for i in input().split()] # Пользователь вводит элементы множества
    return clear_set(elements)


def input_graphic(): # Пользователь задаёт график
    print("Введите мощность графика: ", end="")
    card = int(input()) # Пользователь задаёт мощность графика
    print("Введите пары графика:")
    elements = []
    for k in range(card):
        elements.append(tuple([int(i) for i in input().split()])) # Пользователь вводит пары графика
    return clear_set(elements)


def input_match():
    print("Задание области отправления:")
    x = input_set() # Пользователь задаёт область отправления
    print("Задание области прибытия:")
    y = input_set() # Пользователь задаёт облать прибытия
    print("Задание графика:")
    g = input_graphic() # Пользователь задаёт график
    return x, y, g


def set_union(a: list, b: list): # Объединение множеств
    d = a.copy() # Копируем все элементы множества А во множество D
    for e in b: # Для каждого элемента множества В
        if e not in d: # Если его нет в D
            d.append(e) # Добавляем его в D
    return clear_set(d)


def match_union(a, b): # Объединение соответствий
    # Объединением соответствия является объединение областей прибытия и его графика
    return set_union(a[0], b[0]), set_union(a[1], b[1]), set_union(a[2], b[2])


def set_intersect(a: list, b: list): # Пересечение множеств
    d = [] # Создадим новое пустое множество D
    for e in a: # Для каждого элемента множества А
        if e in b: # Если оно также есть и в B
            d.append(e) # Добавляем его в D
    return clear_set(d)


def match_intersect(a, b): # Пересечение соответствий
    # Пересечением соответствий является кортеж из пересечений всех его элементов
    return set_intersect(a[0], b[0]), set_intersect(a[1], b[1]), set_intersect(a[2], b[2])

 
def set_diff(a: list, b: list): # Разность множеств
    d = [] # Создадим новое пустое множество
    for e in a: # Для каждого элемента множества А
        if e not in b: # Если его нет в B
            d.append(e) # Добавим этот элемент во множество D
    return clear_set(d)


def match_diff(a: list, b: list): # Разность соответствий 
    # Разность соответствий является график разностей всех его элементов
    return set_diff(a[0], b[0]), set_diff(a[1], b[1]), set_diff(a[2], b[2])


def set_sym_diff(a: list, b: list): # Разность симметрическая множества
    d1 = set_diff(a, b) # Находим разность А и В
    d2 = set_diff(b, a) # Находим разность В и А
    return set_union(d1, d2) # Объед


def match_sym_diff(a: list, b: list): # Симметрическая разность соответствий
    # Симметрической разностью соответствий является кортеж симметрических разностей его компонент
    return set_sym_diff(a[0], b[0]), set_sym_diff(a[1], b[1]), set_sym_diff(a[2], b[2])


def graphic_inverse(a: list): # Инверсия графика
    d = [] # Создадим новое пустое множество d
    for e in a: # Для каждого элемента графика A
        d.append((e[1], e[0])) # Добавим в D элемент инверсированную пару
    return clear_set(d)


def match_inverse(a: list): # Инверсия соответствия
    # Инверсией соответствия (X, Y, G) является соответствие (Y, X, G^-1)
    return a[1], a[0], graphic_inverse(a[2])


def graphic_compose(a: list, b: list): # Композиция графиков
    d = [] # Создадим новое пустое множество
    for ae in a: # Для каждого элемента А
        for be in b: # Для каждого элемента B
            if ae[1] == be[0]: # Если вторая компонента элемента А равна первой компоненте элемента B
                d.append((ae[0], be[1])) # Добавим элемент в D, где первая компонента элемента
                                         # равна первой компоненте взятой пары из А, а вторая 
                                         # равна второй компоненте взятой пары из B
    return clear_set(d)


def match_compose(a: list, b: list): # Композиция соответствия
    # Композицией соответствий (X, Y, G) и (U, V, F) является соответствие (X, V, G*F)
    return a[0], b[1], graphic_compose(a[2], b[2])


def decart(a, b): # Декартово произведение множеств
    d = [] # Создадим новое пустое множество
    for ae in a: # Для каждого элемента множества А (x)
        for be in b: # Для каждого элемента множества В (y)
            d.append((ae, be)) # Добавим в D новый элемент (x, y)
    return clear_set(d)


def match_addition(a: list): # Дополнение соответствия
    # Дополнением соответствия (X, Y, G) является соответствие (X, Y, X*Y\G)
    return a[0], a[1], set_diff(decart(a[0], a[1]), a[2])


def image(a: list): # Образ множества при соответствии
    print("Задание множества M:")
    m = input_set() # Пользователь задаёт множество M
    d = [] # Создадим новое пустое множество D
    for me in m: # Для каждого элемента множества М
        for ge in a[2]: # Для каждого элемента графика
            if ge[0] == me: # Если первая компонента взятой пары графика
                            # равна взятому элементу множества M,
                d.append(ge[1]) # добавляем вторую компоненту взятой пары графика в D
    return clear_set(d)


def prototype(a: list): # Прообраз множества при соответствии
    print("Задание множества N:") 
    n = input_set() # Пользователь задаёт множество N
    d = [] # Создадим новое пустое множество D
    for ne in n: # Для каждого элемента множества N
        for ge in a[2]: # Для  каждой пары графика соответствия
            if ge[1] == ne: # Если вторая компонента взятой пары графика
                            # равна взятому элементу множества N
                d.append(ge[0]) # Добавляем первую компоненту взятой пары графика в D
    return clear_set(d)


def constriction(a: list): # Сужение соответствия на множество
    print("Задание множества W:")
    w = input_set() # Пользователь задаёт множество W
    d = [] # Создадим новое пустое множество D
    for ge in a[2]: # Для каждого элемента графика при соответствии
        if ge[0] in w: # Если первая компопнента графика принадлежит множеству W
            d.append(ge) # Добавим в D взятую пару графика
    return w, a[1], d # Сужением (X, Y, G) на W является (W, Y, D)


def print_set(a: list): # Вывод множества в математической форме
    print("{", end="") 
    for i, e in enumerate(a):
        if i != len(a) - 1:
            print(e, end=", ")
        else:
            print(e, end="")
    print("}", end="")


def print_match(a: tuple): # Вывод соответствия 
    print("(", end="")
    print_set(a[0])
    print(", ", end="")
    print_set(a[1])
    print(", ", end="")
    print_set(a[2])
    print(")")


def clear_set(a): # Удаление повторов в множестве
    d = [] # Создадим новое пустое множество D
    for ae in a: # Для каждого элемента в A
        if ae not in d: # Если этого элемента нет в D
            d.append(ae) # Добавляем его во множество D
    return d


def main():
    # Пользователь задаёт соответствие А
    print("Задание соответствия А:")
    a = input_match()
    # Пользователь задаёт соответствие B
    print("Задание соответствия В:")
    b = input_match()

    print("Выберите операцию:\n"
          "\t1. Объединение соответствий А и В\n"
          "\t2. Пересечение соответствий А и В\n"
          "\t3. Разность соответствий А и В\n"
          "\t4. Симметрическая разность соответствий А и В\n"
          "\t5. Инверсия соответствия А\n"
          "\t6. Композиция соответствий А и В\n"
          "\t7. Дополнение соответствия А\n"
          "\t8. Образ множества М при соответствии А\n"
          "\t9. Прообраз множества N при соответствии A\n"
          "\t10. Сужение соответствия А на множестве W\n"
          "Ваш выбор:", end="")

    # Пользователь выбирает операцию
    choice = input() 
    print("Результат:")
    if choice == "1": # Если пользователь хочет найти объединение
        print_match(match_union(a, b))
    elif choice == "2": # Если пользователь хочет найти пересечение
        print_match(match_intersect(a, b))
    elif choice == "3": # Если пользователь хочет найти разность
        print_match(match_diff(a, b))
    elif choice == "4": # Если пользователь хочет найти сим. разность
        print_match(match_sym_diff(a, b))
    elif choice == "5": # Если пользователь хочет найти инверсию
        print_match(match_inverse(a))
    elif choice == "6": # Если пользователь хочет найти композицию
        print_match(match_compose(a, b))
    elif choice == "7": # Если пользователь хочет найти дополнение
        print_match(match_addition(a))
    elif choice == "8": # Если пользователь хочет найти образ
        print_set(image(a))
        print()
    elif choice == "9": # Если пользователь хочет найти прообраз
        print_set(prototype(a))
        print()
    elif choice == "10": # Если пользователь хочет найти сужение
        print_match(constriction(a))
    else:
        print("Такой операции не существует.")
    # Завершаем алгоритм


if __name__ == "__main__":
    main()